# 基础知识
链接：https://javabetter.cn/sidebar/sanfene/network.html
### 说下计算机网络体系结构
OSI七层模型： 应用层，表示层，会话层，传输层，网络层， 数据链路层， 物理层
TCP/IP四层模型：应用层， 传输层， 网际层，网络接口层
5层结构：应用层，传输层，网络层，数据链路层， 物理层 

简单说， OSI七层模型是理论上的网络通信模型， TCP/IP四层模型是实际使用的网络通信模型，5层结构是为了解释网络原理而折中的网络通信模型
> OSI七层模型

国际化标准组织制定的用于计算机或通信设备互联的标准体系 
应用层: 应用层协议制定的是应用进程间通信和交互的协议规则，常见的协议有：HTTP，FTP， DNS， SMTP（邮件服务），SNMP（简单网络管理，解决远程管理网络设备）
表示层： 数据的安全，表示，压缩。 确保一个系统的应用层所发送的数据可以被另一个系统应用层读取
会话层：建立，管理， 终止会话， 是应用程序和网络之间的接口
传输层：提供源端口和目的端口可靠透明数据传输，为不同主机上的进程间提供逻辑通信
网络层：将网络地址翻译成物理地址，实现不同网络间的路径选择，解决主机到主机间的通信问题，常见协议有：ICMP（互联网控制消息协议）， IGMP（互联网管理协议），IP
数据链路层： 在物理层提供比特流服务的基础上， 提供相邻节点之间的数据链路
物理层: 建立，维护，断开物理链接

### 说下每层模型对应的网络协议
应用层：Http，DNS，FTP，NFS（网络文件系统协议），WAIS（互联网协议7，在internet上搜索信息的深层方式），SMTP（简单邮件服务协议），
telnet（使用虚拟终端的形式，提供双向，以文字字符串为主的命令行接口交互功能），SNMP（简单网络管理，解决远程管理网络设备）
表示层：TIFF， JPEG，GIF， PICT
会话层：RPC，SQL，NFS，NetBios， names，appleTalk
传输层：TCP，UDP
网络层：IP， ICMP（网络中设备用于数据传输相关问题的协议，主要用途之一是数据是否在正确时间到达目的地），
ARP（地址解析协议，将IP地址转换为mac地址的协议），RAPP（将mac地址转换成IP地址的协议），
RIP（简单内部网关协议），IPX（互联网分组交换协议，提供分组寻址和选择路由的功能，保证可靠到达）
数据链路层：FDDI（在光缆上发送数字信号的协议），Frame Relay（公用数据网通用协议），HDLC（点到点数据透明传输），PPP（两点建立链接）
物理层：EIA/TIA（232），EIA/TIA（232）

### 数据在各层是如何传输的
对于发送方，从上层至下层层层包装。 对于接收方， 从下层到上层层层解包装
* 发送方的应用程序向接收方应用程序发送数据
* AP先将数据交给本机的应用层，应用层将数据加上控制信息H5，交给传输层
* 传输层将数据添加控制信息H4，交给网络层
* 网络层将数据添加控制信息H3，交给数据链路层
* 数据链路层将控制单元分成两部分，H2 T2，分别加到数据单元的首尾
* 最后的物理层，进行比特流的传输

### 从浏览器地址栏输入 url 到显示主页的过程？
DNS 解析：将域名解析成对应的 IP 地址。
TCP 连接：与服务器通过三次握手，建立 TCP 连接
向服务器发送 HTTP 请求
服务器处理请求，返回 HTTp 响应
浏览器解析并渲染页面
断开连接：TCP 四次挥手，连接结束

### 说说 DNS 的解析过程
首先会查找浏览器的缓存,看看是否能找到www.baidu.com对应的 IP 地址，找到就直接返回；否则进行下一步。
将请求发往给本地 DNS 服务器，如果查找到也直接返回，否则继续进行下一步；
本地 DNS 服务器向根域名服务器发送请求，根域名服务器返回负责com的顶级域名服务器的 IP 地址的列表。
本地 DNS 服务器再向其中一个负责com的顶级域名服务器发送一个请求，返回负责baidu.com的权限域名服务器的 IP 地址列表。
本地 DNS 服务器再向其中一个权限域名服务器发送一个请求，返回www.baidu.com所对应的 IP 地址。

# DNS解析为什么用udp而不是tcp
1. 速度快，没有域名缓存的时候，会从跟域名服务器，（一级）顶级域名服务器，（二级）权限服务器等迭代查询，节省多出来tcp链接断开的时间

UDP的弱点：
1. 由于历史原因，物理链路最小MTU = 576， UDP最大限制在512字节，当DNS传输的数据大于512字节， 最简单的办法就是重新用TCP查询

总结：
1. DNS在域名解析的时候， 会根据DNS响应报文的大小来选择UDP或者TCP,但大多数情况不会超过512
2. DNS在区域传输的时候用的是TCP

# 说说websocket 和 socket区别
1. socket 就是 IP + 端口 + 协议， 它完成了对TCP/IP的高度封装，方便开发者进行变成，他是一个网络编程的标准接口
2. websocket是伴随H5出现的， 为了解决http不能持久化链接的问题，他是一个应用层通信协议（全双工通信协议，他允许在单个TCP链接上双向通信）

# 说说你了解的端口和对应的服务
21: ftp
22: ssh 登陆
23: telnet 远程登陆
53： DNS域名解析服务
1080： sockets
80：http
443: https
3006: mysql

# http常见状态码
101：切换请求协议
200：请求成功
301：永久重定向
302：临时重定向
400：请求语法错误，服务器无法理解
401：当前请求需要认证
403：服务器理解请求，但拒绝
500：服务器内部错误

# 说下HTTP报文的结构
请求报文结构
* 报文首部
  * 请求行
  * 请求首部字段
  * 通用首部字段
  * 实体首部字段
  * 其他
* 空行（CR + LF）不能省略，是区分报文首部和主体的标识
* 报文主体
响应报文结构
* 报文首部
  * 状态行
  * 响应首部字段
  * 通用首部字段
  * 实体首部字段
  * 其他
* 空行（CR + LF）不能省略，是区分报文首部和主体的标识
* 报文主体

# http如何设置长链接，什么时候会超时
> 如何设置长链接

Connection: keep-alive
> 什么时候超时

httpd守护进程中设置keep-alive timeout，header中也可
TPC长链接的三个参数：
1. tcp_keepalive_intvl = 15
2. tcp_keepalive_probes = 5
3. tcp_keepalive_time = 1800
tcp建立长链接后， 闲置时间超过tcp_keepalive_time， 就会发送侦测包，如果没有收到对方的ack，就会每隔tcp_keepalive_intvl发送一次侦测包，知道发送了tcp_keepalive_probes次，就会丢弃该链接

# 为什么要用https
解决问题：
窃听风险，篡改风险，冒充风险
信息加密，校验机制，身份证书

# https工作流程
关键词：公私钥，数字证书，加密，对称加密，非对称加密
1. 客户端请求https的端口443
2. 服务端有一套数字证书，包含公钥，证书颁发机构，失效时间等
3. 客户端收到证书后，验证合法，将随机生成一个对称私钥，将私钥用公钥加密发给服务端
4. 服务端用非对称加密私钥解开客户端传过来的私钥
5. 然后用解开的客户端私钥来加密需要返回的数据
6. 服务器将加密的数据返回到客户端
7. 客户端用密钥解开数据得到最终数据

# 客户端怎么验证证书的合法性
CA颁发证书时，会在证书上添加数字签名1， 客户端用同样的hash算法和CA公钥生成签名2， 签名1 == 签名2 证书就是合法的

# TCP 三次握手
初始，客户端和服务端都处于CLOED状态， 服务端监听客户端的请求，变为listen状态
第一次握手，客户端发起请求，（syn=1， seq=1），状态变成syn_sent
第二次握手，服务端收到请求，发送ack=1，syn 给客户端，状态变成syn_rev
第三次握手，客户端收到请求，发送ack状态变成established，服务器收到请求，状态同样变成established

# 只有两次会怎样
1. 资源浪费
2. 接收过期失效请求发生错误
第二次握手服务器会发送ack等数据给客户端，如果这次包丢了客户端没有接收到， 没有第三次握手的确认，服务器会认为链接可用并一直开着端口，并且在客户端超时重传下次链接来的时候开启新端口来接收，这样就造成了很多资源的浪费

# 四次呢？
三次足够，四次浪费

# 三次每一次没有收到报文的情况
第一次服务端没收到syn， 客户端一直重传， 服务端不做反应
第二次客户端没有收到服务端的ack， 客户端一直重传，服务端阻塞在accept
第三次服务端没有收到客户端的ack，服务端一直重传，客户端以为已经建立好链接，将数据发送过去，服务端收到数据发送RST，告知客户端没有准备好

# 第二次握手传回了ack， 为什么要传回syn
ack是确认收到客户端发送的握手报文， syn告诉客户端，服务器收到的确实是客户端发来的

# 第三次握手可以携带收据吗
可以， 第三次握手客户端已经处于established 状态，此时链接已经建立成功， 能携带数据，但不携带数据处于安全考虑，攻击者每次在syn中携带大量数据新，会造成cpu和内存损耗

# 说说半链接队列和syn flood攻击的关系
半链接队列: 在服务器回复ack + syn变成syn_REVD状态之后就会被放到syn队列（半链接队列）
全链接队列：完成三次握手的链接会放到全链接队列， 等待应用取走

flood攻击：就是在第一次握手时，攻击这不断发送syn包，服务器收不到ack，就不会释放syn队列中的旧链接，从而占满syn队列（半链接队列），导致后续正常链接无法处理
应对办法： 
syn cookie：根据数据包的原地址，端口等信息构建cookie， 将其作为syn发送，收到后正确验证后建立链接，否则丢弃该包
syn proxy： 防火墙收到ack后建立真正链接， 否则不建立

# 四次挥手过程
数据交互完成后，两端都可以发起断开链接请求，这里假定客户端发起
初始状态： 两端都处于established
第一次挥手：客户端发起fin=1 seq=u，此时状态变成fin_wait1
第二次挥手：服务端发起ack=1， 此时服务端状态变成closed_wait, 客户端接收后变成fin_wait2状态
第三次挥手：服务端发起fin=1 ack=1， 此时服务端状态变成Last_ack状态，
第四次挥手: 客户端发起ack， 并处于time_wait 等待2msl （报文在网络中一来一回的最大时间）没有收到服务端的ack就关闭链接，服务端收到ack同样关闭链接变成closed状态

# 断开链接为什么要四次
从fin包的发送就能得知： 
在客户端发送fin时，服务端会先发一个ack，处理完手头的事务
处理完后，再发fin + ack 告诉客户端处理完了，我同意断开链接
服务端ack和fin是分开传送的， 所以断开链接要比建立链接多一次挥手的过程

# 为什么要等待2msl
1. 为了让客户端的确认链接真的到达服务端，因为如果没有到达，服务端会在这个时间内重新发送第三次握手的fin，客户端收到后会重置time_wait的时间，继续等待
2. 为了能让此链接所有历史数据在网络中消失，这样下一次链接就不会出现受上一次历史链接的脏数据了

# 为什么是2msl
报文最大生存时间，超过这个时间会被丢弃， 报文在网络中一来一回的最大传输时间

# 什么是保活计时器（keepalive timer）
建立TCP链接后，如果客户端突然挂了，服务器应该有措施断开链接释放资源，保活计时器就是为了解决这种场景的
每次收到客户端的数据，时间就会重置，keepalive timer 一般会保持两个小时，而后服务器会发送探活侦测包，每隔75秒发送10次仍得不到回应会断开链接释放资源


