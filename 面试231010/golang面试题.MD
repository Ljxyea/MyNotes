# make和new的区别```func new(Type) *Typefunc make(t Type, size ...IntegerType) Type```相同： 分配内存区别： 1. 参数个数：    a. new 只有一个Type参数    b. make Type 和可选的整型参数， 2. 返回值    a. new *Type    b. make Type3. 应用场景a. make map， slice和channelb. new 除引用类型之外的其他类型# 数组和切片的区别1. 数组是值类型2. 切片是数组中连续片段的引用， 所以是引用类型， 其工作机制相当于数组指针的封装， 由point， len， cap组成# for range 变量的地址会发生什么变化for range 时创建每个元素的副本， 所以地址不会变化# 多个defer的顺序， 在什么时候修改返回值延迟函数，1. 多个defer的顺序，LIFO（后入先出）的顺序，可理解为压入栈中2. 执行时机： return value > return > defer3. 修改返回值时机： 有名返回值， 或者返回函数指针# 单引号， 双引号， 反引号的区别1. 单引号表示byte（uint8） 和 rune（int32）类型， 默认rune， byte 强调数据是raw data，而不是数字， rune 表示unicode 的code point2. 双引号表示字符串， 实际上是字符数组， 可以用索引访问某个字节， 用len访问长度3. 反引号表示字符串字面量， 不支持转义# 函数和方法的区别1. 函数不属于任何类型， 方法是特殊类型# = 和 := 的区别1. = 赋值变量， := 定义变量# 指针的作用1. 一个指针可以指向任意变量的地址， 它所指向的地址在32位和64位地址中分别占用4和8字节# go允许多个返回值吗可以# go有异常类型吗error# 如何高效拼接字符串1. + 使用它会遍历字符串， 计算并开辟新的空间来存储新的字符串2.  fmt.Sprintf 由于使用了接口参数， 必须使用反射获取至， 有性能损耗3. strings.Builder： 用WriteString（）进行拼接， 内部实现是指针 + 切片， 同时String（） 返回凭借后的字符串， 它是直接把[]byte转换成string， 从而避免了变量拷贝4. bytes.Buffer： 底层是个切片， byte类型缓冲器5. strings.join 基于strings.Builder实现的总结： strings.Join ≈ strings.Builder > bytes.Buffer > "+" > fmt.Sprintf6. 引申： byte和string的高性能转换， 使用unsafe.Pointer 进行指针转换# 如何判断map中是否存在某个key```golangvar sample map[int]intif _,ok = sample["key"]; ok {	return }```# go支持默认和可选参数吗不支持，可以使用结构体， 切片， 函数参数来代替# 如何交换两个变量的值a， b = b, a# go tag的作用为结构体提供属性， 常见的有：1. json 字段名称2. gorm 数据库字段名3. form gin框架里面数据字段名# 获取结构体的所有tag```GOLANGpackage mainimport (	"fmt"	"reflect")type Author struct {	Name         int      `json:Name`	Publications []string `json:Publication,omitempty`}func main() {	t := reflect.TypeOf(Author{})	for i := 0; i < t.NumField(); i++ {		name := t.Field(i).Name		s, _ := t.FieldByName(name)		fmt.Println(name, s.Tag)	}}```# 如何判断切片相等reflect.DeepEqual() ， 但反射非常影响性能。# 结构体打印时，%v 和 %+v 的区别1. %v输出结构体各成员的值；2. %+v输出结构体各成员的名称和值；3. %#v输出结构体名称和结构体各成员的名称和值# go中如何表示枚举值```gopackage mainconst (	B = 1 << (10 * iota)	KiB 	MiB	GiB	TiB	PiB	EiB)```# 空 struct{} 的用途struct{}本身不占任何空间，可以避免任何多余的内存分配。# go里面的int和int32是同一个概念吗？int8占1个字节，int16占2个字节，int32占4个字节，int64占8个字节。32位系统 int 4字节64系统 int 占8字节