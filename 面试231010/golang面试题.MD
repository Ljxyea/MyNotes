# make和new的区别```func new(Type) *Typefunc make(t Type, size ...IntegerType) Type```相同： 分配内存区别： 1. 参数个数：    a. new 只有一个Type参数    b. make Type 和可选的整型参数， 2. 返回值    a. new *Type    b. make Type3. 应用场景a. make map， slice和channelb. new 除引用类型之外的其他类型# 数组和切片的区别1. 数组是值类型2. 切片是数组中连续片段的引用， 所以是引用类型， 其工作机制相当于数组指针的封装， 由point， len， cap组成# for range 变量的地址会发生什么变化for range 时创建每个元素的副本， 所以地址不会变化# 多个defer的顺序， 在什么时候修改返回值延迟函数，1. 多个defer的顺序，LIFO（后入先出）的顺序，可理解为压入栈中2. 执行时机： return value > return > defer3. 修改返回值时机： 有名返回值， 或者返回函数指针# 单引号， 双引号， 反引号的区别1. 单引号表示byte（uint8） 和 rune（int32）类型， 默认rune， byte 强调数据是raw data，而不是数字， rune 表示unicode 的code point2. 双引号表示字符串， 实际上是字符数组， 可以用索引访问某个字节， 用len访问长度3. 反引号表示字符串字面量， 不支持转义# 函数和方法的区别1. 函数不属于任何类型， 方法是特殊类型# = 和 := 的区别1. = 赋值变量， := 定义变量# 指针的作用1. 一个指针可以指向任意变量的地址， 它所指向的地址在32位和64位地址中分别占用4和8字节# go允许多个返回值吗可以# go有异常类型吗error# 如何高效拼接字符串1. + 使用它会遍历字符串， 计算并开辟新的空间来存储新的字符串2.  fmt.Sprintf 由于使用了接口参数， 必须使用反射获取至， 有性能损耗3. strings.Builder： 用WriteString（）进行拼接， 内部实现是指针 + 切片， 同时String（） 返回凭借后的字符串， 它是直接把[]byte转换成string， 从而避免了变量拷贝4. bytes.Buffer： 底层是个切片， byte类型缓冲器5. strings.join 基于strings.Builder实现的总结： strings.Join ≈ strings.Builder > bytes.Buffer > "+" > fmt.Sprintf6. 引申： byte和string的高性能转换， 使用unsafe.Pointer 进行指针转换# 如何判断map中是否存在某个key```golangvar sample map[int]intif _,ok = sample["key"]; ok {	return }```# go支持默认和可选参数吗不支持，可以使用结构体， 切片， 函数参数来代替# 如何交换两个变量的值a， b = b, a# go tag的作用为结构体提供属性， 常见的有：1. json 字段名称2. gorm 数据库字段名3. form gin框架里面数据字段名# 获取结构体的所有tag```GOLANGpackage mainimport (	"fmt"	"reflect")type Author struct {	Name         int      `json:Name`	Publications []string `json:Publication,omitempty`}func main() {	t := reflect.TypeOf(Author{})	for i := 0; i < t.NumField(); i++ {		name := t.Field(i).Name		s, _ := t.FieldByName(name)		fmt.Println(name, s.Tag)	}}```# 如何判断切片相等reflect.DeepEqual() ， 但反射非常影响性能。# 结构体打印时，%v 和 %+v 的区别1. %v输出结构体各成员的值；2. %+v输出结构体各成员的名称和值；3. %#v输出结构体名称和结构体各成员的名称和值# go中如何表示枚举值```gopackage mainconst (	B = 1 << (10 * iota)	KiB 	MiB	GiB	TiB	PiB	EiB)```# 空 struct{} 的用途struct{}本身不占任何空间，可以避免任何多余的内存分配。# go里面的int和int32是同一个概念吗？int8占1个字节，int16占2个字节，int32占4个字节，int64占8个字节。32位系统 int 4字节64系统 int 占8字节# init函数是什么时候执行的import –> const –> var –>init()–>main()一个文件可以有多个init()函数！但是多个init包的执行顺序不做保证# 如何知道变量分配到栈还是堆变量离开作用域没有被引用，优先分配到栈，否则分配到堆逃逸的可能情况: 变量大小不确定， 变量类型不确定， 变量内存大于用户栈， 暴露给外部指针# Go GC的工作原理1.3 标记清除确定需要暂停stw1.5三色标记白色： 不确定对象， 黑色： 存活对象，灰色： 子对象待处理1.8 三色标记 + 混合写屏障# 函数返回局部指针的变量是否安全发现局部变量超出局部作用域会分到堆上， 避免内存泄露#为什么会有携程泄露1. 缺少接收器， 导致发送阻塞2. 缺少发送器， 导致接受阻塞3. 死锁， 互相抢占资源4. 创建携程没有回收# 死锁的条件1. 互斥2. 请求与保持3. 不剥夺4. 循环等待# 如何控制协程数目GOMAXPROCS 限制的是同时执行用户态Go代码的操作系统线程的数量，默认等于CPU的核数。对于CPU密集型任务，太大会引起线程频切换对于IO密集型任务，适当增大会提高效率# uint类型的变量1和2， 相减得到什么数字结果溢出， 32系统 2^32 - 1; 64系统 2^64-1# init 在main函数执行， 同一个包的顺序不确定# go竟态条件两个携程分别对a=1 进行a++操作所得结果不一定等于2 这就叫竞态竞争# defer 可以捕获goroutine的子goroutine吗不可以， 他们处于不同的P中# 说说 atomic底层怎么实现的.CAS方式， 利用乐观锁的方式进行检测， 本质不断占用cpu资源来避免加锁的开销