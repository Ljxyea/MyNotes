## golang

**golang中make和new的区别**

	1. make只能分配及初始化类型为slice,map,chan等的类型, 且返回类型就是他们本身, 而不是他们的指针类型, 而mew可以分配任意类型的数据
	1. new返回的是指针, 即*Type, make返回引用, 即Type
	1. new分配的内存空间被清零, make分配空间后, 会进行初始化
	1. 小对象且不用在作用域外生存在栈上分配内存, 大对象在堆上分配

**数组和切片的区别**

1. array长度是固定的, slice长度不是固定的
2. 结构不同, slice比array多出一个Cap字段, 可以理解为slice只是数组一小段的引用
3. 初始化方式不同 array [int]/[...]; slice []type
4. unsafe.sizeof不同, slice返回的是切片的描述符为固定的 24字节, array返回的是元素个数
5. 函数传递参数的方式不同, 一个值传递, 一个引用传递

* 切片扩容的源码逻辑

1. 如果期望容量是当前容量的两倍就用期望容量
2. 如果期望容量小于1024就用double容量
3. 如果大于1024就循环每次增加25%, 直到新容量大于期望容量

* 切片append之后的逻辑

​		如果slice发生了扩容此时的扩容后的slice已经和之前的slice毫无关系

* 切片指针append只有的逻辑

​		slice指针修改之后还是改的原有slice

* for range array和slice的区别 ??

**go defer, 多个defer的顺序, defer在什么时机会修改返回值**

​	作用: defer延迟函数,  释放资源, 收尾工作; 如释放锁, 关闭文件, 关闭连接; 铺货panic

​	避坑指南: defer函数紧跟在资源打开后面, 否则defer可能得不到执行, 导致内存泄漏

​	多个defer调用循序LIFO后入先出, defer后的操作可以理解为压入栈中

 	解析: 函数return语句并不是原子级的, 实际上return只代理汇编指令ret. defer语句实在返回前执行, 所以返回过程是: **[设置返回值 -> 执行defer -> ret],** defer可以修改函数最终返回值, 修改时机: **有名返回值或者函数返回指针**

​	参数会在声明时求值, 而不是在调用时

**能介绍下rune类型吗**

​	rune是int32的别名, byte是uint8的别名, rune用单引号'这是rune'表示

**单引号, 双引号, 反引号的区别**

​	单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。

​	双引号，才是字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度

​	反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。

**Go支持默认参数或可选参数吗**

​	不支持, 可以使用函数式(type Option func(option *ConnOption))和可变参数(interface{})

**Go语言tag有什么用, 如何获取一个结构体所有的tag**

```
type Person struct {
    Name//字段名称 string //字段类型 `json:"name"` // 这就是tag
    Age  int    `json:"age"`
    Addr string `json:"addr,omitempty"` // omitempty 默认为字段类型的零值, 尽量用指针类型
}
```

tag的作用和是否能被json decode正常解析

1. 如果name首字母小写, 则为private 不能解析
2. 如果name首字母大写, 有tag name和tag一样; 无tag与name一样

如何获取tag:

​	用reflect反射包来获取, t = reflect.TypeOf(stru).Elem() ; t.Filed(i).Tag.Get("json")

​	NumField是结构体中含有几个字段

​	json也可以换成其他tag的名字

**Go的面向对象是如何实现的**

​	封装(结构体首字母大小写), 继承(结构体包含), 多态(使用interface定义方法, 再使用结构体实现)

ps: 多态的应用场景, 如果你对同一类事务做出多种判断来区分实现, 这个时候就应该警醒了, 能够用到switch和if的地方, 用多态同样可以解决

**结构体和结构体指针调用有什么区别**

与参数的值传递和引用传递一致

**map的底层实现**

​	map的底层数据结构是拉链法实现的哈希表(数组加链表);

​	**makemap底层逻辑:**

1. 计算哈希占用的内存是否移除或者超出能分配的最大值
2. 调用runtime.fastrand获取一个随机的哈希种子
3. 根据传入的hint计算出需要的最小需要的桶的数量
4. 使用makeBucketArray创建用于保存的桶的数组

​	**预创建溢出桶 (hint计算出的桶数量B 决定了溢出桶的数量)**

1. 当B < 4, 不创建溢出桶以节省开销
2. 当B>= 4, 预创建2^B-4个溢出桶

​	**正常情况下**, 正常桶和溢出桶的内存空间都是连续的, 但是当没有可用的溢出桶时, 通过newobject创建的溢出桶是与原有的溢出桶和正常桶的内存空间不是连续的

​	**Hash的低几位用来确定桶号**

​	**扩容**

	1. 扩容条件: (noverflow为溢出桶的数量)

​		a. 装载因子超过6.5时(count/2^B)

​		b. 哈希使用了太多溢出桶 [noverflow >= uint(1) << (B&15))]  即溢出桶大于2^B  最多2^15 = 32768个溢出桶

2. 扩容方式

​		a.如果这次扩容时溢出桶太多导致的, 那这次扩容就是等量扩容, 触发sameSizeGrow, 当持续向哈希插入数据, 并将他们全部删除时, 如果哈希表中的数据么有超过阈值, 就会不断积累溢出桶, 造成缓慢的内存泄漏, sameSizeGrwo会创建新桶保存数据, 垃圾回收会清理老的溢出桶并释放内存

​       b. 双倍扩容时会分流到新的两个桶中(取模), 且元素再分配的过程是在调用写操作的时候增量进行的, 不会造成性能的瞬时抖动

**map查找过程**

​	mapaccess1通过哈希函数和哈希种子来解析当前key的hash, 再通过bucketMark和add获取桶号和高8位, 通过高8位在对应桶号中查找对应的key位置, 在正常桶中找不到就去找溢出桶, 再对比完整的key和key[i]的值获取val[i]

**map中删除一个key, 他的内存会释放吗**

	1. 如果删除的元素时值类型, 如int, float, bool, string以及数组和struct, map的内存不会自动释放
	1. 如果删除的元素时引用类型, 如slice, map, chan等, 会自动释放, 但是释放的内存是子类型占用的内存
	1. map设置为nil后, 内存会被回收

**怎么处理对map进行并发, 有没有其他方案** ?

1. sync.Map
2. 单纯加锁
3. 分段加锁

**nil map和空map有何不同**

​	操作上不同, 空map可以赋值, 但是nil map不可以

**nil 切片和空切片有什么不同**

​	nil切片指向了空地址, 空切片有固定地址只是内存为空

​	判断空切片的方式 len(slice) == 0

​	判断nil切片的方法 slice = nil

**context结构是什么样的? context使用场景和用途**

​	**结构:**

```
type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key interface{}) interface{}
}
```

​	**使用场景和用途:**

		1. 请求链路传值
		1. 取消耗时操作, 及时释放资源

​	**使用注意点**:

	1. context整自顶向下传值, 反之则不可以
	1. 如果有cancel, 一定要保证调用, 否则会造成资源泄漏 , 比如timer泄漏
	1. context一定不能为nil, 如果不确定, 可以使用context.TODO生成一个empty的context

**go channel的底层实现原理**

​	



1. go channel的底层实现原理
2. 讲讲Go的chan底层数据结构和主要使用场景
3. 向channel发送数据和从channel读数据的流程是什么样的
4. nil, 关闭的channel, 有数据的channel, 再进行读, 写, 关闭会怎么样? 
5. select实现原理
6. 什么是GMP
7. 进程, 线程, 协程有什么区别
8. 抢占式调度室如何抢占的
9. M和P的数量问题
10. Go什么时候会发生阻塞,  阻塞时调度器会怎么做
11. GMP有哪些状态
12. GMP能不能去掉P层会怎么样
13. 如果有一个G一直占用资源怎么办, 什么是work stealing算法
14. 除了mutext以为还有哪些方式安全读写共享变量
15. Go如何实现原子操作
16. Mutex是悲观锁还是乐观锁, 悲观锁, 乐观锁是什么
17. Mutex有几种模式
18. goroutine的自旋占用资源如何解决
19. channel死锁的场景
20. 怎么控制并发数
21. 多个goroutine对同一个map写会panic, 异常是否可以用defer捕获
22. 如何优雅的实现一个goroutine池
23. 无缓冲channel和有缓冲channel有什么区别
24. 为什么会有协程泄露
25. Go可以限制运行时操作系统线程的数量吗? 常见的goroutine操作函数有哪些
26. 如何控制协程数量
27. 如果有若干个giroutine, 有一个panic会怎么样
28. defer可以捕获goroutine的子goroutine吗
29. 进程挂了怎么办
30. Grpc是什么
31. GC是怎么实现的
32. go的 gc 算法是怎么实现的？ （得物，出现频率低）
33. GC 中 stw 时机，各个阶段是如何解决的？ （百度）
34. GC的触发时机
35. 谈谈内存泄露, 什么情况下回内存泄露? 怎么定位排查内存泄露问题
36. **golang的内存逃逸, 什么情况下回发生内存逃逸**
37. 简述Go是如何分配内存的
38. channel分配在栈上还是堆上, 哪些对象分配在堆上, 哪些对象分配在栈上
39. 介绍一下大对象和小对象, 为什么小对象多了会造成gc压力

## mysql

**索引的数据结构**

​	B+tree

**哈希索引**

​	基于哈希表实现, 只有memory存储引擎支持hash索引



1. 索引的数据结构
2. 哈希索引
3. hash索引和B+树索引的区别
4. 为什么B+树比B树更合适实现数据库索引
5. 红黑树, B树, B+树对mysql的适用性
6. 索引有什么分类
7. 什么是最左匹配原则
8. 什么是聚簇索引
9. 什么是覆盖索引
10. 索引的设计原则
11. 索引什么时候会失效
12. 什么是前缀索引
13. myisam和innodb的区别
14. mvcc实现原理
15. 幻读,脏读
16. mysql怎么避免幻读
17. 共享锁和排它锁
18. 大表怎么优化, mysql怎么调优
19. binlog, redologo, undologo
20. binlog和undologo有什么区别网络
21. 讲一下mysql架构
22. 分库分表
23. 什么是分区表
24. 分区的问题
25. 查询语句执行流程
26. 更新语句执行过程
27. exist和in的区别
28. mysql中int(10) 和char(10)的区别
29. truncate, delete, drop的区别
30. having和where的区别
31. 什么是mysql主从同步
32. 为什么要做主从同步
33. 乐观锁和悲观锁是什么
34. 用过processlist吗
35. 什么是回表
36. 自增主键, uuid主键, 还有long int主键的优缺点
37. mysql读写有瓶颈如何处理

网络编程

1. TCP三次握手(2次,4次不行吗), 四次挥手的过程(为什么要等2MSL的时间才关闭)
2. 三次握手中每一次没收到报文分别会发生什么情况
3. 第二次握手传回来ack, 为什么还要传回syn
4. 第三次握手可以携带数据吗
5. close-wait和 time-wiat状态和意义
6. time-wait状态过多会导致什么问题, 怎么解决
7. TCP怎么保证传输过程的可靠性
8. https的工作原理
9. 说说HTTP常用的状态码及其含义
10. 负载均衡有哪些实现方式
11. 说说BIO/BIO/AIO的区别
12. 你怎么理解同步和阻塞
13. 谈下你对Reactor模型的理解
14. 说说DNS的解析过程
15. DNS为什么要用UDP
16. 说说websocket与socket的区别
17. 说一下你了解的端口及对应的服务
18. 说一下GET和POST的区别
19. GET的长度限制是多少
20. HTTP请求的过程与原理
21. 说一下HTTP的报文结构
22. 说下HTTP 1.0, 1.1, 2.0, 3.0的区别
23. http如何实现长链接, 在什么时候会超时 
24. 为什么要https 解决了什么问题
25. 如何理解http协议是无状态的
26. 说说session和cookie的区别
27. 分布式环境下session怎么处理呢
28. 说说办理按揭和syn flood攻击的关系吗
29. 保活计时器有什么作用
30. close-wait和 time-wiat状态和意义
31. time-wait状态过多会导致什么问题, 怎么解决
32. 说说TCP报文首部的格式
33. 说说TCP的流量控制
34. TCP的滑动窗口
35. 说说TCP的拥塞控制
36. 说说TCP的重传机制
37. 说说TCP的粘包和拆包
38. IP的定义和作用
39. IP地址有哪些分类
40. 域名和IP的关系, 一个IP可以用多个域名吗
41. IPV4地址不够如何解决
42. 说下ARP协议的工作过程
43. 为什么既有IP地址, 又有MAC地址
44. ICMP协议的功能呢
45. 说下PING的原理
46. 说说有哪些安全攻击
47. DNS劫持了解吗
48. 什么是CSRF攻击, 如何避免
49. 什么是xss攻击, 如何避免
50. 对称加密和非对称加密有什么区别
51. rsa和aes算法有什么区别

redis

1. Redis哈希表进行rehash的出发时机是什么
2. Redis的RDB和AOF机制各自的优缺点是什么, 这两种机制是否可以混合使用
3. Redis经常被称为单线程的系统, 你如何理解Redis的单线程模型
4. Redis的事务操作有哪些命令? Redis事务能保证原子性吗
5. Redis的惰性删除策略是否会导致大量的过期key占用过多的内存
6. 使用Redis主从集群时, 从库的数据能和主库爆出强一致吗
7. 如果在组建Redis切片集群时, 直接使用Hash函数计算key的哈希值, 然后再将实例个数取模, 从而决定数据的放置位置, 这样做好吗
8. Redis数据库中有50万个具有相同key的前缀的键值数据, 现在希望把这些数据读取出来, 你会使用什么方法
9. 请列举一些Redis常见的应用场景
10. Redis作为缓存使用时, 发生缓存雪崩和缓存击穿有什么区别吗
11. Redis数据淘汰策略使用的LRU是标准的LRU算法吗
12. 说说Redis基本的数据类型有哪些
13. Redis为什么快
14. 为什么Redis6.0之后改用多线程呢
15. 知道什么是热key吗, 热key问题怎么解决
16. Redis的过期策略有哪些
17. name定期+惰性都没有删除过期的key